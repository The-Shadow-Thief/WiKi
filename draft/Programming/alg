#title ALG

<p>

* 数据结构

**0. array，list， stack， queue**，hash，可散列表，再散列表，桶式散列

hash冲突的解决；填充率；

**1. tree**

森林（结构）、二叉树、平衡二叉树、()

**2. B树**

用于数据库中的数据类型，主要是M叉树，M叉树对根、节点和叶节点的元素的个数有一定的限制。

根节点有2个到M子节点；非根节点的关键字的个数是<latex>$ \lceil M/2 \rceil \le j \le M $</latex>

**3. 图**

稠密矩阵和邻接表两种情况表示。

拓扑排序、有向图、无相图、有圈图、负圈图、最小生成树、NP完全、Dijkstra（迪杰斯特拉）算法、A*算法、
单源最短距离、多源最短距离、广度优先算法、深度优先算法、强连通、欧拉问题、模拟退火算法（Recuit Algorithm)、

* 排序算法

**0. 插入排序**

时刻保持这前面的元素是排好序的。

**1.[[alg-heapsort.html][ 堆排序]]**

利用二叉堆排序，二叉堆的性质是min/max在第一个元素，然后兑换最后一个元素和第一个元素，二叉堆的大小减1，
然后重新构建二叉堆，然后重复上面的操作，直至二叉堆的大小为1。N趟二叉堆的重构，所有时间复杂度为O(Nlog(N))。

**2. [[alg-shellsort.html][希尔排序]]**

增量排序，设置一个增量的序列，按照这个序列间隔依次进行排序。这种排序的时间复杂度很大程度取决于增量序列的选择。
其时间复杂度为亚二次，因为其复杂度小于N^2

**3. [[alg-quicksort.html][快速排序]]**

着重在几点上，a.枢纽元素的选择，避免最好的情况出现。书中用的取首末中三个值，取中值的方法。然后安装请前后分别来遍历，
将大于和小于枢纽的元素分两边，对大于枢纽和小于枢纽的部分分别重复上面的操作。
此外在N很小的情况下，快速排序的效率并不高这时可以切换到插入排序的状态下进行。


**4. [[alg-basesort.thml][链式基本排序]]**

**5. [[alg-mergesort.html][二路归并排序]]**

主要是用于外部排序。内存不足以支撑排序的情况下，需要多次将数据读取到内存中进行排序。这种情况下影响算法的效率不再是
算法本身的复杂，而是读取外层的大小和方式了。安排好读取的顺序、次数以及大小才是外部排序迫切需要解决的问题。

**[[alg-haffman.html][6. 最优二叉树]]**


* 算法设计

**1.贪婪算法**

*调度问题*

单机调度、多机调度（联机算法和脱机算法）。

联机算法就是输入值一次一个元素的输入，处理完一个元素在处理一个元素。

脱机算法则表示数据一次性都输入进来，然后再最优的处理的方法来选择出来所有的元素。

这两个的关系就像口试和笔试的关系，口试，就是回答完了一个问题后再回答另外一个问题；
而笔试是将试卷都发到考生的手上，考生可以根据试卷的难易程度选择答题的顺序。

*Huffhan编码*

贪婪算法得到的结果不一定是最优，但是按照某种规律接近最优的。
在一定要求不是很高的情况下可以用贪婪算法的结果来代替最优结果，
宁可要一个简单的次优的结果也不希望要一个复杂的最优结果。

**2.分治算法**

就是将问题分成几部分，然后处理，快速处理就是一个经典的例子。

找到临近点算法、选择算法、多位数乘法。

分治算法复杂度的算法

<latex>$ T(N) = a T(N/b) + O(N^k) $</latex>

<latex>$ a > b^k \to  O(N^{\log_b a}) $</latex>

<latex>$ a = b^k \to  O(N\log_b N) $</latex>

<latex>$ a < b^k \to  O(N^k) $</latex>


当然还有两一组情况,没太记清楚：TODO

<latex>$ T(N) = a T(N/b) + O(N^k \log N) $</latex>


**3.动态规划**

通过将历史记录保存下来的方法来实现递归转非递归。

一个高效的递归是可以忍受的，但是一个低效的递归是无法容忍；
这个是因为数学公式很容易的转化成递归的方式，也就很容易的转化code，
但是有些情况下，所用的语言无法很好的诠释这个算法，造成性能的下降。

例如斐波那契数列，其中存在在大量的重复计算，如果简单的转化成递归的话，
其复杂度成指数增长，这个时候就要将递归转成非递归算法。

经典的例子有：

*多个矩阵乘法* 

其结合的不同会引起最终的计算复杂度有很大的差异

*最优二叉树*

*Wagner-Fischer algorithm*


</p>

[[WelcomePage][UP]]
